\subsection{Cartes CC 2538}

La première carte que nous avons utilisé est la CC 2538 de \emph{Texas Instruments} (TI), branchée sur le kit de développement \emph{SmartRF 06}.

\subsubsection{Présentation}

\todo[Images et descriptions]

\subsubsection{Test des cartes}

\todo[Copies d’écran RF studio \& description]

\subsubsection{Programmes exemple}

\paragraph{Installation sur les cartes}

\emph{Contiki} fournit un script \emph{Python} pour installer un programme sur une carte CC 2538, appelé \emph{cc2538-bsl} \todo[référence documentation], qui est intégré dans le \texttt{Makefile}.
Nous avons initialement suivi les étapes décrites dans sa documentation pour configurer la communication avec les cartes CC 25358, mais le résultat a invariablement été un message d’erreur indiquant que la carte ne répondait pas aux solicitations du script.

\todo[Copie de l’erreur]

Nous nous sommes alors tournés vers le logiciel développé par TI \todo[nom].
Celui-ci ne fonctionnant que sur un système Windows \todo[Mac aussi ?], nous l’avons installé sur la machine hôte de la machine virtuelle.
Afin de transmettre facilement les fichiers compilés par \emph{Contiki}, nous avons utilisé les outils de partage de dossier proposés par \emph{VirtualBox}.

\todo[Copies d’écran du logiciel]

\paragraph{Manipulations des LEDs et boutons}

Nous avons commencé par tester l’exemple conçu spécifiquement pour la CC 2538, classé dans le dossier \texttt{cc2538dk}.
Ce programme utilise plusieurs fonctionnalités de la carte de développement \emph{SmartRF 06}, mais nous avons concentré notre étude sur celles utiles pour le développement de notre démonstrateur :

\begin{itemize}
	\item le programme utilise les boutons pour sélectionner la fonctionnalité à tester, que nous avons utilisé comme entrée dans notre programme de démonstration ;
	\item plusieurs des démonstrations font clignoter les LEDs, que nous avons utilisées comme sortie de notre programme de démonstration.
\end{itemize}

\paragraph{Communication UDP}

Afin de nous familiariser avec la pile réseau de \emph{Contiki}, nous avons ensuite compilé et exécuté les programmes de l’exemple classé dans le dossier \url{ipv6/simple-udp-rpl}.
Cet exemple est constitué de trois programmes qui échangent des messages en UDP sur 6LowPAN.

Tous ces programmes envoient leurs messages à des instants aléatoires de chacun des intervales consécutifs de vingt secondes suivant le démarrage du programme, ce qui assure un temps moyen de ving secondes entre les messages.
Nous n’avons pas trouvé de documentation pour ce choix, mais on peut supposer qu’il réduit les problèmes de collisions.

\subparagraph{\textit{Broadcast}}

Ce programme peut être utilisé seul sur plusieurs cartes, qui envoient alors régulièrement des messages à l’ensemble de leurs voisins.
Chaque carte indique sur son flux de sortie standard l’envoi et la réception de messages, ce qui permet de vérifier que la connectivité est établie.

Nous avons modifié l’exemple de façon à numéroter les messages, pour vérifier que tous les messages étaient reçus.
C’est à cette occasion que nous avons rencontré le problème posé par les variables locales (voir \cref{variables-locales}) et que nous avons cherché à mieux comprendre l’architecture de \emph{Contiki}.

\subparagraph{\textit{Unycast}}

Les deux programmes d’exemple en \textit{unycast}, \texttt{unicast-receiver} et \texttt{unicast-sender} sont conçus pour fonctionner ensemble : une des deux cartes a un rôle de serveur (\textit{receiver}), l’autre de client ((\textit{sender})).
Comme dans l’exemple de \textit{broadcast}, l’envoi et la réception de messages est indiquée sur le flux standard de sortie ; il sont en plus déjà numérotés.

Cette architecture serveur-client utilise un mécanisme de services intégré à \emph{Contiki} sous le nom de \emph{servreg-hack} : ce processus se charge d’annoncer aux nœuds voisins qu’il fournit un service (identifié par un nombre entier), de retenir les services annoncés par ses voisins et de retransmettre ces annonces.
Il permet ainsi de ne pas coder en dur dans le code du programme les adresses IP, rendant possible l’évolution d’un réseau d’objets connectés sans recompilation de tous les programmes lors d’un changement dans la répartition des tâches.

\paragraph{Développement d’un programme d’action à distance}

Nous sommes repartis de ces deux exemples pour concevoir les deux programmes de démonstration suivants.

\begin{description}
	\item[\texttt{leds-slave}]
		La carte exécutant ce programme a le rôle de serveur d’affichage ; elle expose ce service grâce au mécanisme fourni par \emph{servreg-hack}.
		Lorsqu’un client la solicite, elle met à jour l’état de ses LEDs en fonction de la demande.
	\item[\texttt{leds-master}]
		La carte exécutant ce programme réagit aux actions de l’utilisateur sur ses boutons en envoyant des requêtes de modification au serveur d’affichage.
		Afin de pouvoir suivre la mise à jour des LEDs sur la carte serveur, ce programme met aussi à jour ses propres LEDs pour refléter l’état dans lequel le serveur devrait se trouver un fois à jour.
\end{description}

La carte exécutant ce dernier programme permet à l’utilisateur de modifier un à un l’état des quatre LEDs, en faisant correspondre l’appui sur un chacun quatre boutons directionels avec le changement d’état d’une des LEDs.

Nous avions dans un premier temps imaginé n’envoyer au serveur des requêtes ne contenant que les modifications à effectuer, mais comme les messages entre les cartes étaient trop souvent perdus, nous avons décidé d’envoyer un état complet à chaque mise à jour.
Plus précisément, le client envoie deux types de demandes de mises à jour (indifférenciables du point de vue du serveur) : lorsque l’utilisateur change l’état des LEDs en appuyant sur un des boutons, celui-ci est immédiatement envoyé au serveur afin que la mise à jour soit le plus rapide possible ; pour ne pas laisser le serveur dans un état incohérent trop longtemps si ce message de modification est perdu, l’état est de nouvaeu envoyé toutes les dix secondes.

Les implémentations initiales de ces deux types d’envois étaient indépendantes temporellement : les messages de rappel étaient envoyés exactement toutes les dix secondes, quelles que soient les actions de l’utilisateur.
Afin d’éviter d’encombrer la pile 6LowPAN et le canal hertzien inutilement avec une mise à jour de rappel suivant immédiatement la mise à jour de changement, le compteur temporel des mises à jour de rappel est désormais réinitialisé systématiquement lors d’une action de l’utilisateur.
